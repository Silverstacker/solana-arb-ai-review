# Gemini Code Review - 2025-11-28

## Executive Summary

The codebase is structured cleanly with good separation of concerns between data models (`rate.py`, `loop.py`) and logic (`loop_finder.py`, `cross_platform.py`). The algorithmic complexity for finding loops is efficient (O(N) due to hash map lookups).

However, there is a **Critical Logic Error** in the cross-platform yield calculation and a **High Risk** regarding hardcoded financial parameters that could lead to inaccurate risk assessments.

---

## 1. BUGS & ERRORS

### [SEVERITY: CRITICAL] - Incorrect Cross-Platform Return Formula

**File:** `loop.py`  
**Line(s):** 153-157  
**Issue:** The calculation for cross-platform returns subtracts the full `borrow_apy` from the net result. However, borrowing interest is only charged on the borrowed amount (determined by LTV), not the principal collateral amount.  
**Impact:** The scanner significantly underestimates profitability. It incorrectly assumes you pay interest on 100% of your equity value, rather than the LTV % of your equity.  
**Fix:** Scale the borrow APY by the LTV.

```python
# Current (Wrong)
cost_leg1 = leg1.borrow_apy

# Correct
# You pay borrow_apy on the borrowed amount (equity * LTV)
cost_leg1 = leg1.borrow_apy * (leg1.ltv / 100)
```

**STATUS: ✅ FIXED** - Commit `b11ca61`

---

### [SEVERITY: MEDIUM] - Division by Zero Risk in LTV Calculation

**File:** `rate.py` (and duplicated in `loop.py`)  
**Line(s):** 30-32  
**Issue:** While there is a check for `ltv >= 100`, floating point precision issues or dirty data could theoretically result in `ltv` being extremely close to 100 (e.g., 99.9999), resulting in massive or infinite leverage values before the check catches it.  
**Impact:** Potential crash or `inf` values propagating through yield calculations.  
**Fix:** Cap LTV at a safe maximum (e.g., 99%) for the calculation.

**STATUS: ✅ FIXED** - Commit `1b5b79c` (capped at 98%)

---

### [SEVERITY: LOW] - `None` Type Safety in Sort Keys

**File:** `cross_platform.py`  
**Line(s):** 72  
**Issue:** `x.calculate_returns().get('best_net', 0)` uses `0` as a default.  
**Impact:** If a loop is malformed, it filters to the bottom rather than raising an error. This is acceptable behavior but explicit filtering is safer.

**STATUS:** Acceptable as-is

---

## 2. CODE QUALITY

### [SEVERITY: HIGH] - Hardcoded Financial Constants

**File:** `rate.py`  
**Line(s):** 51-75  
**Issue:** `KNOWN_UNDERLYING` and `KNOWN_LTV` are hardcoded.  
**Impact:** This is the biggest implementation risk. DeFi rates and LTV configs change frequently via DAO votes or protocol updates. If `ONyc` drops to 0% underlying or USDC LTV changes to 75%, your scanner will output wrong data, potentially leading to bad trades.  
**Fix:** These values must be fetched dynamically from the protocol SDKs or an API (like DeFiLlama) at runtime.

**STATUS:** ⏳ GitHub Issue #1 created

---

### [SEVERITY: MEDIUM] - Code Duplication (DRY Principle)

**File:** `rate.py` vs `loop.py`  
**Line(s):** `rate.py`: 28-32 vs `loop.py`: 23-27  
**Issue:** The logic for `max_leverage` is identical in `RateEntry` and `LoopLeg`.  
**Impact:** If you update the safety logic in one, you might forget the other.  
**Fix:** Have `LoopLeg` delegate to a shared utility function.

**STATUS: ✅ FIXED** - Commit `1b5b79c` (extracted `calculate_max_leverage()`)

---

### [SEVERITY: LOW] - Mutable Default Arguments

**File:** `loop.py`  
**Line(s):** 73  
**Issue:** `leverage_levels: List[int] = None` - Python best practice uses `Optional[List[int]]`.  
**Fix:** Update type hint.

**STATUS: ✅ FIXED** - Commit `48416c8`

---

## 3. ERROR HANDLING

### [SEVERITY: MEDIUM] - Silent Failures in Yield Calculation

**File:** `loop.py`  
**Line(s):** 98, 145  
**Issue:** If `self.legs` is empty or insufficient, the functions return an empty `dict {}`.  
**Impact:** Consumers expect keys like `'best_net'`. Accessing `returns['best_net']` will raise a `KeyError`.  
**Fix:** Return a standardized dictionary with zeroed values and error message.

```python
if len(self.legs) < 2:
    return {'best_net': 0.0, 'error': 'Insufficient legs'}
```

**STATUS: ✅ FIXED** - Commit `db6f28e`

---

## 4. SECURITY & DATA INTEGRITY

### [SEVERITY: MEDIUM] - LTV Trust

**File:** `rate.py`  
**Line(s):** 59-71  
**Issue:** Manually mapping tokens to LTVs (e.g., `'USDC': 80`).  
**Impact:** Different protocols have different LTVs for the same token. Kamino might allow 80% on USDC, while Jupiter might allow 75%. Using a global map ignores protocol-specific risk configurations.  
**Fix:** The LTV must be associated with the specific `(Platform, Market, Token)` tuple, not just the Token.

**STATUS:** ⏳ Included in GitHub Issue #1

---

## 5. PERFORMANCE

### [SEVERITY: LOW] - Efficient Lookups

**File:** `cross_platform.py`  
**Analysis:** The code uses `defaultdict` to build simple lookup tables. This converts what could be an O(N²) operation into O(N).  
**Verdict:** Excellent. No changes needed.

---

## Answers to Questions

### 1. Are the leverage calculations mathematically correct?

- **Single Platform:** ✅ Yes. The formula `(supply * leverage) - (borrow * (leverage - 1))` is correct.
- **Cross Platform:** ❌ No (was incorrect, now fixed).

### 2. Is the cross-platform formula right?

**Original:** `Net = leg1_supply + (leg2_supply × LTV1/100) - leg1_borrow`

**NO.** It was incorrect regarding the borrow cost.

**Correct formula:**
```
Net = Supply₁ + (Supply₂ × LTV₁) - (Borrow₁ × LTV₁)
```

You do not pay borrow interest on your equity. You pay it on the debt. Your debt amount equals Equity × LTV.

### 3. What's the biggest risk in this codebase?

**Stale/Hardcoded Data.** The `KNOWN_LTV` and `KNOWN_UNDERLYING` dictionaries.

If a protocol changes parameters and your code still thinks the old values are valid, the scanner will recommend trades that are unprofitable or will revert on-chain.

### 4. What would you prioritize fixing first?

1. ✅ **Fix the Cross-Platform Math** - Creates false negatives (DONE)
2. ⏳ **Remove Global LTV Mapping** - Make LTV per (Platform, Market, Token)
3. ⏳ **Add Unit Tests** - Verify math with known inputs

---

## Summary of Fixes Applied

| Commit | Description |
|--------|-------------|
| `b11ca61` | Fix cross-platform borrow cost (scale by LTV) |
| `1b5b79c` | Add MAX_SAFE_LTV cap, extract shared leverage function |
| `48416c8` | Use shared function, fix type hints |
| `db6f28e` | Add explicit error messages in failure returns |

---

## Open Issues Created

- **Issue #1:** Replace hardcoded LTV/APY constants with dynamic fetching
- **Issue #2:** Add unit tests for loop calculations
